// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: scores.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const createScore = `-- name: CreateScore :one
INSERT INTO scores (
	completion_time,
	hard_quizzes_done,
	medium_quizzes_done,
	easy_quizzes_done, 
	total_score, 
	user_id
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING scores.id
`

type CreateScoreParams struct {
	CompletionTime    int64
	HardQuizzesDone   int32
	MediumQuizzesDone int32
	EasyQuizzesDone   int32
	TotalScore        int32
	UserID            uuid.UUID
}

func (q *Queries) CreateScore(ctx context.Context, arg CreateScoreParams) (int64, error) {
	row := q.db.QueryRow(ctx, createScore,
		arg.CompletionTime,
		arg.HardQuizzesDone,
		arg.MediumQuizzesDone,
		arg.EasyQuizzesDone,
		arg.TotalScore,
		arg.UserID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getScoreByID = `-- name: GetScoreByID :one
SELECT id, completion_time, hard_quizzes_done, medium_quizzes_done, easy_quizzes_done, total_score, user_id FROM scores
WHERE id = $1
`

func (q *Queries) GetScoreByID(ctx context.Context, id int64) (Score, error) {
	row := q.db.QueryRow(ctx, getScoreByID, id)
	var i Score
	err := row.Scan(
		&i.ID,
		&i.CompletionTime,
		&i.HardQuizzesDone,
		&i.MediumQuizzesDone,
		&i.EasyQuizzesDone,
		&i.TotalScore,
		&i.UserID,
	)
	return i, err
}

const getScoresByUserID = `-- name: GetScoresByUserID :many
SELECT id, completion_time, hard_quizzes_done, medium_quizzes_done, easy_quizzes_done, total_score, user_id FROM scores
WHERE user_id = $1
`

func (q *Queries) GetScoresByUserID(ctx context.Context, userID uuid.UUID) ([]Score, error) {
	rows, err := q.db.Query(ctx, getScoresByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Score
	for rows.Next() {
		var i Score
		if err := rows.Scan(
			&i.ID,
			&i.CompletionTime,
			&i.HardQuizzesDone,
			&i.MediumQuizzesDone,
			&i.EasyQuizzesDone,
			&i.TotalScore,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTheHighestTotalScore = `-- name: GetTheHighestTotalScore :one
SELECT max(scores.total_score) as score FROM scores
GROUP BY scores.total_score
ORDER BY scores.total_score DESC
LIMIT 1
`

func (q *Queries) GetTheHighestTotalScore(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, getTheHighestTotalScore)
	var score interface{}
	err := row.Scan(&score)
	return score, err
}

const getUserHighestScoreByEmail = `-- name: GetUserHighestScoreByEmail :one
SELECT max(scores.total_score) as score FROM scores
JOIN users ON scores.user_id = users.id
WHERE users.email = $1
`

func (q *Queries) GetUserHighestScoreByEmail(ctx context.Context, email string) (interface{}, error) {
	row := q.db.QueryRow(ctx, getUserHighestScoreByEmail, email)
	var score interface{}
	err := row.Scan(&score)
	return score, err
}

const usersBestScorePagination = `-- name: UsersBestScorePagination :many
WITH max_scores as (
    SELECT 
        user_id, 
        max(total_score) as max_score
    FROM 
        scores
    WHERE 
        scores.total_score > 0 AND scores.total_score < $1
    GROUP BY 
        user_id
)
SELECT 
    users.email, 
    scores.easy_quizzes_done, 
    scores.medium_quizzes_done, 
    scores.hard_quizzes_done, 
    scores.completion_time, 
    scores.total_score as score
FROM 
    max_scores
JOIN 
    scores ON scores.user_id = max_scores.user_id AND scores.total_score = max_scores.max_score
RIGHT JOIN 
    users ON scores.user_id = users.id
ORDER BY 
    scores.total_score DESC
LIMIT 10
`

type UsersBestScorePaginationRow struct {
	Email             string
	EasyQuizzesDone   int32
	MediumQuizzesDone int32
	HardQuizzesDone   int32
	CompletionTime    int64
	Score             int32
}

func (q *Queries) UsersBestScorePagination(ctx context.Context, totalScore int32) ([]UsersBestScorePaginationRow, error) {
	rows, err := q.db.Query(ctx, usersBestScorePagination, totalScore)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersBestScorePaginationRow
	for rows.Next() {
		var i UsersBestScorePaginationRow
		if err := rows.Scan(
			&i.Email,
			&i.EasyQuizzesDone,
			&i.MediumQuizzesDone,
			&i.HardQuizzesDone,
			&i.CompletionTime,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
